При иерархической кластеризации в зависимости от разных t получалось или 98 кластеров 
(то есть каждое словосочетание было в своем кластере, что бессмысленно), или 1, или 37. 37 - самый осмысленный вариант.

Для к-средних я смотрела на количество элементов в кластере. Если сделать 37, как в первом методе, получалось так:
[16 17 26  6 35  2 30 10 33 17  3 10 31 24  7 15  3 10 34 28 15 19 23  1
  1 10  6 25  8 23  7 17  4  5  3 33 18 27  4 36 18 10  1 22 12 20 20 17
 12 11  9 35 16  5 13 12 17 22  3  0  6  8 30  9  1 13  3  2  7  9  6 27
 21  3 25 22 10  1  3 14 27  0 11 17  9 12  9 28 20  3 30 29 23 32 18 33
 19 11]
Видно, что во многих кластерах по одному элементу. Так как нам хочется выделить несколько больших блоков значений, 
лучше взять поменьше, например 10.
[9 8 4 7 4 6 3 2 1 8 2 2 7 3 2 5 3 2 2 6 5 2 6 4 4 2 7 3 2 6 2 8 3 4 2 1 0
 2 3 5 0 2 4 3 3 4 8 8 3 4 4 4 9 4 6 3 8 5 3 0 7 2 3 3 4 5 2 6 5 3 7 0 7 3
 4 5 2 4 4 3 2 0 4 8 4 3 3 6 8 1 3 7 6 3 0 1 2 4]
В этом случае уже есть большие кластеры с более "регулярными" значениями (4) и маленькие с менее регулярными (1), 
но их немного. Кажется, это то, чего мы хотим добиться.
Если сделать совсем мало, например 3, то явно не будут учитываться периферийные значения:
[1 2 2 0 2 0 2 0 1 2 1 0 0 2 0 0 1 0 0 0 0 0 1 2 2 0 0 2 0 1 0 2 1 2 2 1 1
 0 1 0 1 0 2 2 2 2 2 2 2 2 2 2 1 2 0 2 2 2 2 1 0 0 1 2 2 2 0 2 1 2 0 0 0 1
 2 2 0 2 0 0 0 1 0 2 2 2 2 1 2 0 2 0 1 2 1 1 0 2]
